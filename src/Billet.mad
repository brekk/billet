import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import { always, equals, unless, when } from "Function"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe, isJust } from "Maybe"
import Print from "PrettyPrint"
import String from "String"
import Term from "Terminal"

import { seededAnsi } from "@/Color"



export alias Scope = List String
export type Tag = Tag(Boolean, Scope, String)

instance Eq Tag {
  __EQ__ = (a, b) => serializeTag(a) == serializeTag(b)
}
instance Comparable Tag {
  compare = compareTag
}

scopedTag :: Scope -> String -> Tag
export scopedTag = Tag(true)

export scopedUnTag = Tag(false)

export tag = scopedTag([])
export untag = scopedUnTag([])

isNegated :: Tag -> Boolean
export isNegated = where {
  Tag(x, _, _) =>
    !x
}

isScoped :: Tag -> Boolean
export isScoped = where {
  Tag(_, scope, _) =>
    List.length(scope) > 0
}

getScope :: Tag -> Scope
export getScope = where {
  Tag(_, scope, _) =>
    scope
}

getId :: Tag -> String
export getId = where {
  Tag(_, _, name) =>
    name
}

scopeLength :: Tag -> Integer
export scopeLength = pipe(
  getScope,
  List.length,
)

compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => {
  aName = getId(a)
  bName = getId(b)

  return if (bName == aName) do {
    sA = scopeLength(a)
    sB = scopeLength(b)
    return if (sA == sB) {
      EQ
    } else if (sA > sB) {
      GT
    } else {
      LT
    }
  } else {
    EQ
  }
}

// can we compare Maybes with syntax?
scopeEqual :: Scope -> Scope -> Boolean
export scopeEqual = (a, b) => where(#[a, b]) {
  #[scope1, scope2] =>
    scope1 == scope2
}

hasScope :: Scope -> Tag -> Boolean
export hasScope = (testScope, t) => pipe(
  getScope,
  scopeEqual(testScope),
)(t)

scopeWithinScope :: Scope -> Scope -> Boolean
export scopeWithinScope = (parent, child) => {
  lenPar = List.length(parent)
  lenChild = List.length(child)
  return if (lenChild == 0) {
    true
  } else if (lenPar <= lenChild) {
    pipe(
      List.zip(parent),
      List.all(where { #[a, b] => a == b }),
    )(child)
  } else {
    false
  }
}

_firstAsString :: List String -> String
_firstAsString = pipe(
  List.first,
  fromMaybe(""),
)

isStarTag :: List String -> Boolean
isStarTag = List.endsWith(["*"])

tagInScope :: Scope -> Tag -> Boolean
export tagInScope = (testScope, t) => pipe(
  getScope,
  when(isStarTag, always([])),
  scopeWithinScope(testScope),
)(t)

checkScopes :: List Scope -> Tag -> Boolean
export checkScopes = (scopes, t) => List.any(tagInScope($, t), scopes)

serializeTag :: Tag -> String
export serializeTag = (t) => {
  scope = pipe(
    getScope,
    String.join(":"),
  )(t)
  name = getId(t)
  return name ++ (equals("", scope) ? "" : ":" ++ scope)
}

// TODO: support negated tags next
checkTagScopes :: List Tag -> Tag -> Boolean
export checkTagScopes = (tags, t) => {
  tId = getId(t)
  return pipe(
    List.filter(
      pipe(
        getId,
        (uId) => tId == "*" || uId == tId,
      ),
    ),
    map(getScope),
    checkScopes($, t),
  )(tags)
}

// eventually we could actually parse stuff
parseTag :: String -> Tag
parseTag = (part) => {
  negated = !String.startsWith("-", part)
  return pipe(
    String.trim,
    String.split(":"),
    (list) => {
      segments = List.length(list) == 1 ? [] : List.tail(list)
      return pipe(
        _firstAsString,
        Tag(negated, segments),
      )(list)
    },
  )(part)
}

isEmptyTag :: Tag -> Boolean
isEmptyTag = pipe(
  getId,
  equals(""),
)

parseTags :: String -> List Tag
export parseTags = pipe(
  String.split(","),
  map(parseTag),
  List.reject(isEmptyTag),
)

export alias Trace a = String -> a -> a

makeCapturingProcessor :: Show a => Trace a -> List Tag -> Tag -> a -> Maybe a
export makeCapturingProcessor = (call, tags, t, thing) => (
  checkTagScopes(tags, t)
    ? pipe(
      call(serializeTag(t)),
      Just,
    )(thing)
    : Nothing
)

makeComposableProcessor :: Show a => Trace a -> List Tag -> Tag -> a -> a
export makeComposableProcessor = (call, tags, t, thing) => pipe(
  makeCapturingProcessor(call, tags, t),
  fromMaybe(thing),
)(thing)

// instead of the verbosity of the raw processor, express things as parsable tags
makeParsedProcessor :: Show a => Trace a -> List Tag -> String -> a -> a
export makeParsedProcessor = (call, tags, t, thing) => pipe(
  parseTag,
  makeComposableProcessor(call, tags, $, thing),
)(t)

export makeRawLogger = makeComposableProcessor(IO.pTrace)
export makeParsedLogger = makeParsedProcessor(IO.pTrace)

export makeStyledParsedLogger = (seedPrefix, raw) => makeParsedProcessor(
  (t, x) => pipe(
    seededAnsi(seedPrefix),
    where {
      #[fg, bg] =>
        pipe(
          Term.ansiColor(fg),
          Term.ansiColor(bg),
        )(t)
    },
    IO.pTrace($, x),
  )(t),
)(raw)
