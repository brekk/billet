import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import { equals, when } from "Function"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe, isJust } from "Maybe"
import Print from "PrettyPrint"
import String from "String"



export ROOT_SCOPE = "*"

export alias Scope = List String
export type Tag = Tag(Scope, String)


instance Eq Tag {
  __EQ__ = (a, b) => #[getScope(a), getId(a)] == #[getScope(b), getId(b)]
}
instance Comparable Tag {
  compare = compareTag
}

scopedTag :: Scope -> String -> Tag
export scopedTag = Tag

export tag = Tag([])

isScoped :: Tag -> Boolean
export isScoped = where {
  Tag(scope, _) =>
    List.length(scope) > 0
}

getScope :: Tag -> Scope
export getScope = where {
  Tag(scope, _) =>
    scope
}

getTopScope :: Tag -> String
getTopScope = pipe(
  getScope,
  List.first,
  fromMaybe(ROOT_SCOPE),
)

getId :: Tag -> String
export getId = where {
  Tag(_, name) =>
    name
}

scopeLength :: Tag -> Integer
export scopeLength = pipe(
  getScope,
  List.length,
)

compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => {
  aName = getId(a)
  bName = getId(b)

  return if (bName == aName) do {
    sA = scopeLength(a)
    sB = scopeLength(b)
    return sA == sB ? EQ : sA > sB ? GT : LT
  } else {
    EQ
  }
}

// can we compare Maybes with syntax?
scopeEqual :: Scope -> Scope -> Boolean
scopeEqual = (a, b) => where(#[a, b]) {
  #[scope1, scope2] =>
    scope1 == scope2
}

hasScope :: Scope -> Tag -> Boolean
export hasScope = (testScope, t) => pipe(
  getScope,
  scopeEqual(testScope),
)(t)

checkScopes :: List Scope -> Tag -> Boolean
export checkScopes = (scopes, t) => List.any(hasScope($, t), scopes)

serializeTag :: Tag -> String
export serializeTag = (t) => {
  scope = pipe(
    getScope,
    String.join(":"),
  )(t)
  name = getId(t)
  return scope ++ name
}

// log :: Show a => List (Maybe String) -> Tag -> a -> {}
export log = (scopes, t, thing) => if (checkScopes(scopes, t)) do {
  IO.pTrace(serializeTag(t), thing)
  return thing
} else {
  thing
}

firstAsString :: List String -> String
firstAsString = pipe(
  List.first,
  fromMaybe(""),
)

parseScopes :: String -> List Tag
export parseScopes = pipe(
  String.split(","),
  map(
    pipe(
      String.trim,
      String.split(":"),
      (list) => Tag(List.length(list) == 1 ? [] : List.tail(list), firstAsString(list)),
    ),
  ),
  List.reject(
    pipe(
      getId,
      equals(""),
    ),
  ),
)
