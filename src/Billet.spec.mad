import type { AssertionError } from "Test"
import type { Wish } from "Wish"

import Dict from "Dictionary"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"
import { assertEquals, test } from "Test"
import Wish from "Wish"

import { Tag, compareTag, getId, getScope, isScoped, parseScopes, scopedTag, tag } from "@/Billet"



// testCases :: (Show b, Eq b) => String -> (a -> b) -> Dictionary a b -> Wish TestResult TestResult
testCases = (fn, name, testDict) => pipe(
  Dict.mapWithKey((input, output) => assertEquals(fn(input), output)),
  Dict.values,
  (cases) => test(
    name,
    () => do {
      _ <- Wish.parallel(cases)
      return assertEquals(name, name)
    },
  ),
)(testDict)

testParseScopes = testCases(parseScopes)
testParseScopes(
  "parseScopes - single tags",
  {{ "yo": [scopedTag([], "yo")], "yo:scoped": [scopedTag(["scoped"], "yo")] }},
)
testParseScopes(
  "parseScopes - multiple tags",
  {{
    "a, b, spaced": [tag("a"), tag("b"), tag("spaced")],
    "a,b:belabor": [tag("a"), scopedTag(["belabor"], "b")],
  }},
)
testParseScopes("parseScopes - various garbage", {{ "": [], ",,": [], "::::,": [] }})

// /*
// seems to fail b/c of comparison
testCases(
  isScoped,
  "isScoped - testcase",
  Dict.fromList([#[Tag([], "yo"), false], #[Tag(["yo"], "yo"), true]]),
)
// */


test(
  "getScope",
  () => do {
    _ <- assertEquals(getScope(Tag([], "yo")), [])
    return assertEquals(getScope(Tag(["a", "b"], "yo")), ["a", "b"])
  },
)
