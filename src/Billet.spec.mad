import type { AssertionError } from "Test"
import type { Wish } from "Wish"

import Dict from "Dictionary"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"
import { assertEquals, test } from "Test"
import Wish from "Wish"

import {
  Tag,
  checkScopes,
  getId,
  getScope,
  hasScope,
  isScoped,
  makeParsedLogger,
  makeRawLogger,
  parseTags,
  scopeEqual,
  scopeWithinScope,
  scopedTag,
  serializeTag,
  tag,
  tagInScope,
} from "@/Billet"



// testCases :: (Show b, Eq b) => String -> (a -> b) -> Dictionary a b -> Wish TestResult TestResult
testCases = (fn, name, testDict) => pipe(
  Dict.mapWithKey((input, output) => assertEquals(fn(input), output)),
  Dict.values,
  (cases) => test(
    name,
    () => do {
      _ <- Wish.parallel(cases)
      return assertEquals(name, name)
    },
  ),
)(testDict)

testparseTags = testCases(parseTags)
testparseTags(
  "parseTags - single tags",
  {{ "yo": [scopedTag([], "yo")], "yo:scoped": [scopedTag(["scoped"], "yo")] }},
)
testparseTags(
  "parseTags - multiple tags",
  {{
    "a, b, spaced": [tag("a"), tag("b"), tag("spaced")],
    "a,b:belabor": [tag("a"), scopedTag(["belabor"], "b")],
  }},
)
testparseTags("parseTags - various garbage", {{ "": [], ",,": [], "::::,": [] }})

testCases(
  isScoped,
  "isScoped - testcase",
  Dict.fromList([#[Tag(true, [], "yo"), false], #[Tag(true, ["yo"], "yo"), true]]),
)


testCases(
  getScope,
  "getScope",
  Dict.fromList([#[Tag(true, [], "yo"), []], #[Tag(true, ["a", "b"], "yo"), ["a", "b"]]]),
)

test(
  "scopeEqual",
  () => do {
    return assertEquals(scopeEqual([], []), true)
  },
)

test(
  "hasScope",
  () => do {
    _ <- assertEquals(hasScope(["a", "b"], scopedTag([], "nice")), false)
    return assertEquals(hasScope([], scopedTag([], "nice")), true)
  },
)

test(
  "scopeWithinScope",
  () => do {
    _ <- assertEquals(scopeWithinScope(["a", "b", "c"], ["a"]), false)
    _ <- assertEquals(scopeWithinScope(["a", "b", "c"], []), true)
    _ <- assertEquals(scopeWithinScope([], []), true)
    return assertEquals(scopeWithinScope(["a", "b", "c"], ["a", "b", "c", "d"]), true)
  },
)

testCases(
  scopeWithinScope(["a", "b", "c"]),
  "scopeWithinScope a:b:c",
  {{ ["a"]: false, []: true, ["a", "b", "c", "d"]: true, ["a", "b", "c", "d", "e"]: true }},
)

testCases(scopeWithinScope([]), "scopeWithinScope *", {{ []: true }})

testCases(
  tagInScope(["a", "b", "c"]),
  "tagInScope b:c",
  Dict.fromList([
    #[scopedTag(["a", "b", "c"], "x"), true],
    #[scopedTag(["a", "b", "c", "d"], "x"), true],
    #[scopedTag(["a", "b"], "x"), false],
    #[scopedTag([], "x"), true],
  ]),
)

testCases(
  serializeTag,
  "serializeTag",
  Dict.fromList([
    #[scopedTag(["deeply", "nested", "value"], "a"), "a:deeply:nested:value"],
    #[scopedTag([], "a"), "a"],
  ]),
)

SCOPES = [
  scopedTag(["deep"], "info"),
  tag("warn"),
  tag("log"),
  scopedTag(["deeply", "nested"], "issue"),
]
test(
  "makeRawLogger",
  () => do {
    alog = makeRawLogger(SCOPES)
    _ <- assertEquals(alog(Tag(true, ["deep"], "info"), "[deep] info!"), Just("[deep] info!"))
    _ <- assertEquals(alog(Tag(true, [], "info"), "info info!"), Just("info info!"))
    _ <- assertEquals(alog(Tag(true, [], "unmatched"), "info info!"), Nothing)
    _ <- assertEquals(alog(Tag(true, ["deeply"], "issue"), "skip me!"), Nothing)
    return assertEquals(
      alog(Tag(true, ["deep", "nested"], "info"), "info info!"),
      Just("info info!"),
    )
  },
)

test(
  "makeParsedLogger",
  () => do {
    alog = makeParsedLogger(SCOPES)
    _ <- assertEquals(alog("info:deep", "[deep] info!"), Just("[deep] info!"))
    _ <- assertEquals(alog("info", "information"), Just("information"))
    _ <- assertEquals(alog("unmatched", "unlogged"), Nothing)
    _ <- assertEquals(alog("issue:whatever", "skip me!"), Nothing)
    _ <- assertEquals(alog("info:deep:nested", "info deeply nested!"), Just("info deeply nested!"))
    _ <- assertEquals(alog("*", "k fun star star!"), Just("k fun star star!"))
    return assertEquals(
      pipe(
        IO.pTrace(">>>>>>>>>>>"),
        alog("info:*"),
      )("info star"),
      Just("info star"),
    )
  },
)
