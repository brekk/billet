import type { Random } from "Random"

import { ge } from "Compare"
import Float from "Float"
import Integer from "Integer"
import { repeatWith } from "List"
import Math from "Math"
import R from "Random"
import Term from "Terminal"



export alias Color a = #[a, a, a]

// derive Comparable Color a

export toInteger = where {
  #[r, g, b] =>
    r + g + b
}

export toFloat = where {
  #[r, g, b] =>
    16 + (36 * (r / 255 * 5)) + (6 * (g / 255 * 5)) + (b / 255 * 5)
}

export toTupleFloat = where {
  #[r, g, b] =>
    #[Integer.toFloat(r), Integer.toFloat(g), Integer.toFloat(b)]
}

export toTupleInt = where {
  #[r, g, b] =>
    #[Float.toInteger(r), Float.toInteger(g), Float.toInteger(b)]
}

export toRGB = (v) => {
  r = hexR(v)
  g = hexG(v)
  b = hexB(v)
  return #[r, g, b]
}

toAnsi256 :: (Bits a, Comparable a, Number a) => a -> a -> a -> Float
export toAnsi256 = (r, g, b) => {
  r4 = r >> 4
  g4 = g >> 4
  b4 = b >> 4
  return if (r4 == g4 && g4 == b4) {
    if (r < 8) {
      16
    } else if (r > 248) {
      231
    } else {
      Math.round(((r - 8) / 247) * 24) + 232
    }
  } else {
    16 + (36 * Math.round(r / 255 * 5)) + (6 * Math.round(g / 255 * 5)) + Math.round(b / 255 * 5)
  }
}

MAX_OCTET = 255

colorFromSeed :: Random -> Color Integer
colorFromSeed = (seed) => {
  pull = R.integer(0, MAX_OCTET)
  r = pull(seed)
  g = pull(seed)
  b = pull(seed)
  return #[r, g, b]
}

export genRGB = pipe(
  R.generateFromString,
  colorFromSeed,
)

//ESC[48;2;⟨r⟩;⟨g⟩;⟨b⟩ m Select RGB background color
COLOR_BACKGROUND = 48
//ESC[38;2;⟨r⟩;⟨g⟩;⟨b⟩ m Select RGB foreground color
COLOR_FOREGROUND = 38

toList :: Color a -> List a
export toList = where {
  #[r, g, b] =>
    [r, g, b]
}


export seededSeq = (before, str) => pipe(
  genRGB,
  toList,
  mappend([before, 2]),
  map(show),
)(str)

export rgbInvert = where {
  #[r, g, b] =>
    #[MAX_OCTET - r, MAX_OCTET - g, MAX_OCTET - b]
}

export seededSeqBg = seededSeq(COLOR_BACKGROUND)
export seededSeqFg = seededSeq(COLOR_FOREGROUND)


HALF_OCTET = 0x7f

isMid = ge($, HALF_OCTET)

seeded :: String -> String -> List String
export seeded = (seedPrefix, str) => pipe(
  mappend(seedPrefix),
  genRGB,
  (color) => {
    black = pipe(
      toTupleFloat,
      isLuminous,
    )(color)
    return where(color) {
      #[r, g, b] =>
        map(show)([
          COLOR_FOREGROUND,
          2,
          black ? 0 : MAX_OCTET,
          black ? 0 : MAX_OCTET,
          black ? 0 : MAX_OCTET,
          COLOR_BACKGROUND,
          2,
          r,
          g,
          b,
        ])
    }
  },
)(str)

ansiFgBg :: String -> List String -> String
export ansiFgBg = (t, ansiSeq) => Term.ansiColor(ansiSeq, t)



hexR :: Integer -> Integer
hexR = (raw) => raw >> 16 & 0xff

hexG :: Integer -> Integer
hexG = (raw) => raw >> 8 & 0xff

hexB :: Integer -> Integer
hexB = (raw) => raw & 0xff

luminance :: Color Float -> Color Float
export luminance = where {
  #[r, g, b] =>
    #[(r * 0.2126), (g * 0.7152), (b * 0.0722)]
}

isLuminous :: Color Float -> Boolean
isLuminous = pipe(
  luminance,
  toInteger,
  isMid,
)

contrastL :: Color Float -> Integer
export contrastL = pipe(
  luminance,
  toFloat,
  (x) => isMid(x) ? 0x000000 : 0xffffff,
)
contrastColor :: Color Float -> Color Float
export contrastColor = pipe(
  contrastL,
  (x) => x >= 0x7f ? #[0, 0, 0] : #[MAX_OCTET, MAX_OCTET, MAX_OCTET],
)
