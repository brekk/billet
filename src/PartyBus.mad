import type { Trace } from "@/Processor"
import type { Lazy } from "@/Processor/Lazy"
import type { Tag } from "@/Tag"
import type { Scope } from "@/Tag/Scope"

import { gt } from "Compare"
import Dict from "Dictionary"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"

import { awareOf } from "@/Env"
import _Logger from "@/Log"
import { captured, composed, parsed, styled } from "@/Processor"
import { Tag, id, negated, scoped } from "@/Tag"
import { Scope } from "@/Tag/Scope"



export type Scope
export type Trace
export type Tag
export type Lazy

export type PartyBus a b = PartyBus(Trace a b, List Tag)

export bus = PartyBus


export experience = (verb, str, strScope) => verb(str, strScope)

export avoidWithContext = experience(negated)
export avoid = avoidWithContext($, [])
export allowWithContext = experience(scoped)
export allow = allowWithContext($, [])

alias Ruleset = Dictionary String (List Tag)

insertTag :: String -> Ruleset -> Tag -> Ruleset
insertTag = (name, agg, tag) => if (Dict.includes(name, agg)) {
  Dict.update(List.append(tag), name, agg)
} else {
  Dict.insert(name, [tag], agg)
}

formalizeRuleset :: List Tag -> Ruleset
export formalizeRuleset = (rules) => pipe(
  List.reduce((agg, tag) => insertTag(id(tag), agg, tag), Dict.empty),
)(rules)

/*
rsvp :: PartyBus a b -> Tag -> a -> b
rsvp = (party, event, x) => where (party) {
  PartyBus(fun, rules) => (
    fun,
    rules,
  )
}

*/
