import type { Comparison } from "Compare"

import type { Scope } from "@/Tag/Scope"

import { EQ, GT, LT, gt } from "Compare"
import { always, complement, equals, ifElse, when } from "Function"
import IO from "IO"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import Set from "Set"
import String from "String"
import Term from "Terminal"

import { NoScope, Scope, scopeFromList, scopeLength, scopeWithinScope } from "@/Tag/Scope"



// A Tag lets us segment data
export type Tag = Tag(String, Scope) | NegatedTag(String, Scope) | Wildcard | NoTag

export alias TagList = List Tag

export type TagRange = TagRange(Boolean, TagList) | WildRange

instance Comparable Tag {
  compare = compareTag
}

// CONSTRUCTOR SUGAR

scoped :: String -> List String -> Tag
export scoped = (n, xs) => Tag(n, scopeFromList(xs))

negated :: String -> List String -> Tag
export negated = (n, xs) => NegatedTag(n, scopeFromList(xs))

tag :: String -> Tag
export tag = Tag($, NoScope)
untag :: String -> Tag
export untag = NegatedTag($, NoScope)

// COMPARISONS

equalsTag = (a, b) => a > b

export PARALLEL_SCOPE = EQ
export OUT_OF_SCOPE = LT
export IN_SCOPE = GT


compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => where(#[a, b]) {
  #[Wildcard, _] =>
    IN_SCOPE

  #[_, Wildcard] =>
    IN_SCOPE

  #[NoTag, _] =>
    OUT_OF_SCOPE

  #[_, NoTag] =>
    OUT_OF_SCOPE

  #[Tag(aName, NoScope), Tag(bName, _)] =>
    aName == bName ? IN_SCOPE : PARALLEL_SCOPE

  // comparing two scoped Tags
  #[Tag(aName, aScope), Tag(bName, bScope)] =>
    if (bName == aName) {
      if (scopeWithinScope(aScope, bScope)) {
        IN_SCOPE
      } else {
        OUT_OF_SCOPE
      }
    } else {
      OUT_OF_SCOPE
    }

  // we only care if the names match and one is negated

  #[Tag(aName, _), NegatedTag(bName, _)] =>
    aName == bName ? OUT_OF_SCOPE : PARALLEL_SCOPE

  #[NegatedTag(aName, _), Tag(bName, _)] =>
    aName == bName ? OUT_OF_SCOPE : PARALLEL_SCOPE

  _ =>
    OUT_OF_SCOPE
}

// CHECKS

isWild :: Tag -> Boolean
export isWild = where {
  Wildcard =>
    true

  Tag(x, _) =>
    x == "*"

  _ =>
    false
}

isNegated :: Tag -> Boolean
export isNegated = where {
  NegatedTag(_, _) =>
    true

  _ =>
    false
}

isScoped :: Tag -> Boolean
export isScoped = where {
  Tag(_, Scope(_)) =>
    true

  NegatedTag(_, Scope(_)) =>
    true

  _ =>
    false
}

// ACCESSOR


getScope :: Tag -> Scope
export getScope = where {
  Tag(_, scope) =>
    scope

  NegatedTag(_, scope) =>
    scope

  _ =>
    NoScope
}

getConcreteScope :: Tag -> List String
export getConcreteScope = pipe(
  getScope,
  where {
    Scope(raw) =>
      Set.toList(raw)

    _ =>
      []
  },
)

id :: Tag -> String
export id = where {
  Tag(name, _) =>
    name

  NegatedTag(name, _) =>
    name

  Wildcard =>
    "*"

  NoTag =>
    ""
}

// TRANSFORMS

// eventually we could actually Parse stuff
fromString :: String -> Tag
export fromString = (_part) => if (_part == "*") {
  Wildcard
} else if (_part == "") {
  NoTag
} else do {
  pos = String.startsWith("-", _part)
  part = if (pos) {
    String.drop(1, _part)
  } else {
    _part
  }
  return pipe(
    String.trim,
    String.split(":"),
    List.reject(equals("")),
    (list) => {
      listLen = List.length(list)
      return if (listLen == 0) {
        NoTag
      } else do {
        seg = listLen == 1 ? [] : List.tail(list)
        return pipe(
          _firstAsString,
          (pos ? NegatedTag : Tag)($, scopeFromList(seg)),
        )(list)
      }
    },
  )(part)
}


tagScopeLength :: Tag -> Integer
export tagScopeLength = pipe(
  getScope,
  scopeLength,
)


_firstAsString :: List String -> String
_firstAsString = pipe(
  List.first,
  fromMaybe(""),
)

serialize :: Tag -> String
export serialize = (t) => {
  scope = pipe(
    getConcreteScope,
    String.join(":"),
  )(t)
  name = id(t)
  return name ++ (equals("", scope) ? "" : ":" ++ scope)
}

isNoTag = (x) => x == NoTag

manyFromString :: String -> List Tag
export manyFromString = pipe(
  String.split(","),
  List.reject(equals("")),
  map(fromString),
  List.reject(isNoTag),
)


matches :: List Tag -> Tag -> Boolean
export matches = (xs, t) => {
  name = id(t)
  w = isWild(t)
  return w
    || pipe(
      List.filter(
        (x) => {
          e = equalsTag(x, t)
          o = x > t
          neg = isNegated(x)
          return e && (neg || o)
        },
      ),
      complement(List.isEmpty),
    )(xs)
}
