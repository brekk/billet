import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import type { Scope } from "@/Scope"

import { EQ, GT, LT } from "Compare"
import { always, equals, when } from "Function"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"

import { withinScope } from "@/Scope"



export type Tag = Tag(Boolean, String, Scope) | TagString(String)

instance Eq Tag {
  __EQ__ = (a, b) => serialize(a) == serialize(b)
}
instance Comparable Tag {
  compare = compareTag
}

scoped :: String -> Scope -> Tag
export scoped = Tag(true)

negated :: String -> Scope -> Tag
export negated = Tag(false)

tag :: String -> Tag
export tag = scoped($, [])
untag :: String -> Tag
export untag = negated($, [])

isNegated :: Tag -> Boolean
export isNegated = where {
  Tag(x, _, _) =>
    !x

  TagString(s) =>
    String.startsWith("-", s)
}

isScoped :: Tag -> Boolean
export isScoped = where {
  Tag(_, _, scope) =>
    List.length(scope) > 0

  TagString(s) =>
    String.includes(':', s)
}

indexOf :: Char -> String -> Maybe Integer
indexOf = (needle, haystack) => {
  i = 0
  chars = String.toList(haystack)
  matched = false
  check = (_i) => pipe(
    String.charAt(_i),
    map(equals(needle)),
    fromMaybe(false),
  )(haystack)
  while(i <= List.length(chars) && !matched) do {
    if (check(i)) do {
      matched := true
    }
    i := i + 1
  }
  return matched ? Just(i) : Nothing
}

getScope :: Tag -> Scope
export getScope = where {
  Tag(_, _, scope) =>
    scope

  TagString(s) =>
    pipe(
      parse,
      getScope,
    )(s)
}

// eventually we could actually Parse stuff
parse :: String -> Tag
export parse = (part) => {
  neg = !String.startsWith("-", part)
  return pipe(
    String.trim,
    String.split(":"),
    (list) => {
      seg = List.length(list) == 1 ? [] : List.tail(list)
      return pipe(
        _firstAsString,
        Tag(neg, $, seg),
      )(list)
    },
  )(part)
}

convertTag :: Tag -> Tag
export convertTag = where {
  Tag(n, s, m) =>
    Tag(n, s, m)

  TagString(s) =>
    parse(s)
}


id :: Tag -> String
export id = where {
  Tag(_, name, _) =>
    name

  TagString(s) =>
    pipe(
      parse,
      id,
    )(s)
}

tagScopeLength :: Tag -> Integer
export tagScopeLength = pipe(
  getScope,
  List.length,
)

compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => {
  aName = id(a)
  bName = id(b)

  return if (bName == aName) do {
    sA = tagScopeLength(a)
    sB = tagScopeLength(b)
    return if (sA == sB) {
      EQ
    } else if (sA > sB) {
      GT
    } else {
      LT
    }
  } else {
    EQ
  }
}

hasScope :: Scope -> Tag -> Boolean
export hasScope = (testScope, t) => pipe(
  getScope,
  equals(testScope),
)(t)

_firstAsString :: List String -> String
_firstAsString = pipe(
  List.first,
  fromMaybe(""),
)

_isStarTag :: List String -> Boolean
_isStarTag = List.endsWith(["*"])

inScope :: Scope -> Tag -> Boolean
export inScope = (testScope, t) => pipe(
  getScope,
  when(_isStarTag, always([])),
  withinScope(testScope),
)(t)

checkScopes :: Tag -> List Scope -> Boolean
export checkScopes = (t, scopes) => List.any(inScope($, t), scopes)

serialize :: Tag -> String
export serialize = (t) => {
  scope = pipe(
    getScope,
    String.join(":"),
  )(t)
  name = id(t)
  return name ++ (equals("", scope) ? "" : ":" ++ scope)
}

// TODO: support negated tags next
within :: List Tag -> Tag -> Boolean
export within = (tags, t) => {
  tId = id(t)
  return pipe(
    List.filter(
      pipe(
        id,
        (uId) => tId == "*" || uId == tId,
      ),
    ),
    map(getScope),
    checkScopes(t),
  )(tags)
}


_isEmptyTag :: Tag -> Boolean
_isEmptyTag = pipe(
  id,
  equals(""),
)

parseMany :: String -> List Tag
export parseMany = pipe(
  String.split(","),
  map(parse),
  List.reject(_isEmptyTag),
)
