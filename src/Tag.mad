import type { Comparison } from "Compare"
import type { Maybe } from "Maybe"

import { EQ, GT, LT } from "Compare"
import { always, equals, when } from "Function"
import List from "List"
import { Just, Nothing, fromMaybe } from "Maybe"
import String from "String"



// export alias TagRecord = { negated :: Boolean, name :: String, scopes :: Scope }
// export type Tag2 = Tag2(TagRecord)

export alias Scope = List String

/**
 * A tag is a human identifiable way of segmenting data:
 * - it has an `id` which is a String
 * - it can be negated, which allows for exclusion
 * - it can be scoped, which allows for filtering
 */
export type Tag = Tag(Boolean, String, Scope) | Wildcard

instance Eq Tag {
  __EQ__ = tagEqualsTag
}
instance Comparable Tag {
  compare = compareTag
}

tagEqualsTag = (a, b) => {
  iA = id(a)
  iB = id(b)
  return if (isWild(a) || isWild(b)) {
    true
  } else if ((isNegated(a) || isNegated(b)) && iA == iB) {
    false
  } else {
    id(a) == id(b)
  }
}

// CONSTRUCTOR SUGAR

scoped :: String -> Scope -> Tag
export scoped = Tag(false)

negated :: String -> Scope -> Tag
export negated = Tag(true)

tag :: String -> Tag
export tag = scoped($, [])
untag :: String -> Tag
export untag = negated($, [])

// CHECKS

isWild :: Tag -> Boolean
export isWild = where {
  Wildcard =>
    true

  Tag(_, x, _) =>
    x == "*"
}

isNegated :: Tag -> Boolean
export isNegated = where {
  Tag(x, _, _) =>
    x

  Wildcard =>
    false
}

isScoped :: Tag -> Boolean
export isScoped = where {
  Tag(_, _, scope) =>
    List.length(scope) > 0

  Wildcard =>
    false
}

// ACCESSOR


getScope :: Tag -> Scope
export getScope = where {
  Tag(_, _, scope) =>
    scope

  Wildcard =>
    []
}

// eventually we could actually Parse stuff
fromString :: String -> Tag
export fromString = (_part) => {
  pos = String.startsWith("-", _part)
  part = if (pos) {
    String.drop(1, _part)
  } else {
    _part
  }
  return pipe(
    String.trim,
    String.split(":"),
    (list) => {
      seg = List.length(list) == 1 ? [] : List.tail(list)
      return pipe(
        _firstAsString,
        Tag(pos, $, seg),
      )(list)
    },
  )(part)
}


id :: Tag -> String
export id = where {
  Tag(_, name, _) =>
    name

  Wildcard =>
    "*"
}

tagScopeLength :: Tag -> Integer
export tagScopeLength = pipe(
  getScope,
  List.length,
)

compareTag :: Tag -> Tag -> Comparison
export compareTag = (a, b) => where(#[a, b]) {
  #[Tag(aNeg, aName, aScope), Tag(bNeg, bName, bScope)] =>
    if (bName == aName) {
      if (aNeg || bNeg) {
        aNeg ? LT : GT
      } else do {
        sA = List.length(aScope)
        sB = List.length(bScope)
        return if (sA == sB) {
          EQ
        } else if (sA > sB) {
          GT
        } else {
          LT
        }
      }
    } else if (aNeg || bNeg) {
      aNeg ? GT : LT
    } else {
      EQ
    }

  #[Wildcard, Wildcard] =>
    EQ

  #[Wildcard, _] =>
    LT

  #[_, Wildcard] =>
    GT
}

hasScope :: Scope -> Tag -> Boolean
export hasScope = (testScope, t) => pipe(
  getScope,
  equals(testScope),
)(t)

_firstAsString :: List String -> String
_firstAsString = pipe(
  List.first,
  fromMaybe(""),
)

_isStarTag :: List String -> Boolean
_isStarTag = List.endsWith(["*"])

withinScope :: Scope -> Scope -> Boolean
export withinScope = (parent, child) => {
  lenPar = List.length(parent)
  lenChild = List.length(child)
  return if (lenChild == 0) {
    true
  } else if (lenPar <= lenChild) {
    pipe(
      List.zip(parent),
      List.all(where { #[a, b] => a == b }),
    )(child)
  } else {
    false
  }
}

inScope :: Scope -> Tag -> Boolean
export inScope = (testScope, t) => pipe(
  getScope,
  when(_isStarTag, always([])),
  withinScope(testScope),
)(t)

checkScopes :: List Scope -> Tag -> Boolean
export checkScopes = (scopes, t) => pipe(
  List.any(inScope($, t)),
)(scopes)

serialize :: Tag -> String
export serialize = (t) => {
  scope = pipe(
    getScope,
    String.join(":"),
  )(t)
  name = id(t)
  return name ++ (equals("", scope) ? "" : ":" ++ scope)
}

import IO from "IO"



// TODO: support negated tags next
/*
within :: List Tag -> Tag -> Boolean
export within = (tags, t) => {
  tId = id(t)
  neg = isNegated(t)
  return pipe(
    List.filter(
      pipe(
        id,
        (uId) => tId == "*" || uId == tId,
      ),
    ),
    map(getScope),
    // map((raw) => #[isNegated(raw), getScope(raw)]),
    checkScopes($, t),
  )(tags)
}
*/

matches :: List Tag -> Tag -> Boolean
export matches = (xs, t) => {
  return pipe(
    List.filter((x) => isWild(x) || isWild(t) || (tagEqualsTag(x, t) && x > t)),
    List.length,
    equals(0),
  )(xs)
}


_isEmptyTag :: Tag -> Boolean
_isEmptyTag = pipe(
  id,
  equals(""),
)

manyFromString :: String -> List Tag
export manyFromString = pipe(
  String.split(","),
  map(fromString),
  List.reject(_isEmptyTag),
)
